--------------------------------------------------------------------------------
2017-12-19
delete src/events/ngx_event_openssl.h
delete src/mail/*
--------------------------------------------------------------------------------
宏处理的连接玩法，一个井号#+宏名，用来传递宏值的字符串，且能自动连接相邻字符串。
"SIG" ngx_value(NGX_RECONFIGURE_SIGNAL)
>> "SIG" ngx_value_helper(NGX_RECONFIGURE_SIGNAL)
>> "SIG" #NGX_RECONFIGURE_SIGNAL
>> found #define NGX_RECONFIGURE_SIGNAL   HUP
>> "SIGHUP"

而两个##的例子如下，可以用来连接宏名的
ngx_signal_value(NGX_RECONFIGURE_SIGNAL)
>> ngx_signal_helper(NGX_RECONFIGURE_SIGNAL)
>> SIG##NGX_RECONFIGURE_SIGNAL
>> SIGHUP

ngx_string.h
#define ngx_value_helper(n)   #n
#define ngx_value(n)          ngx_value_helper(n)

search "ngx_value("

ngx_module.h
#define NGX_MODULE_SIGNATURE_0                                                \
    ngx_value(NGX_PTR_SIZE) ","                                               \
    ngx_value(NGX_SIG_ATOMIC_T_SIZE) ","                                      \
    ngx_value(NGX_TIME_T_SIZE) ","

相当于
#define NGX_MODULE_SIGNATURE_0 "8,4,8,"

/usr/include/sys/signal.h
ngx_process.c
ngx_signal_t  signals[] = {
    { ngx_signal_value(NGX_RECONFIGURE_SIGNAL),>>>>>>>>>signal int 值 SIGHUP = 1
      "SIG" ngx_value(NGX_RECONFIGURE_SIGNAL),>>>>>>>>>>字符串 SIGHUP
      "reload",
      ngx_signal_handler },

    { ngx_signal_value(NGX_REOPEN_SIGNAL),>>>>>>>>>>>>>>signal int 值 SIGUSR1 = 30
      "SIG" ngx_value(NGX_REOPEN_SIGNAL),>>>>>>>>>>>>>>>字符串 SIGUSR1
      "reopen",
      ngx_signal_handler },

    { ngx_signal_value(NGX_NOACCEPT_SIGNAL),>>>>>>>>>>>>signal int 值 SIGWINCH = 28
      "SIG" ngx_value(NGX_NOACCEPT_SIGNAL),>>>>>>>>>>>>>字符串 SIGWINCH
      "",
      ngx_signal_handler },

    { ngx_signal_value(NGX_TERMINATE_SIGNAL),>>>>>>>>>>>signal int 值 SIGTERM = 15
      "SIG" ngx_value(NGX_TERMINATE_SIGNAL),>>>>>>>>>>>>字符串 SIGTERM
      "stop",
      ngx_signal_handler },

    { ngx_signal_value(NGX_SHUTDOWN_SIGNAL),>>>>>>>>>>>>signal int 值 SIGTERM = 31
      "SIG" ngx_value(NGX_SHUTDOWN_SIGNAL),>>>>>>>>>>>>>字符串 SIGQUIT
      "quit",
      ngx_signal_handler },

    { ngx_signal_value(NGX_CHANGEBIN_SIGNAL),
      "SIG" ngx_value(NGX_CHANGEBIN_SIGNAL),>>>>>>>>>>>>>字符串 SIGUSR2
      "",
      ngx_signal_handler },

ngx_config.h
#if !(NGX_WIN32)

#define ngx_signal_helper(n)     SIG##n
#define ngx_signal_value(n)      ngx_signal_helper(n)

#define ngx_random               random

/* TODO: #ifndef */
#define NGX_SHUTDOWN_SIGNAL      QUIT
#define NGX_TERMINATE_SIGNAL     TERM
#define NGX_NOACCEPT_SIGNAL      WINCH
#define NGX_RECONFIGURE_SIGNAL   HUP

#if (NGX_LINUXTHREADS)
#define NGX_REOPEN_SIGNAL        INFO
#define NGX_CHANGEBIN_SIGNAL     XCPU
#else
#define NGX_REOPEN_SIGNAL        USR1
#define NGX_CHANGEBIN_SIGNAL     USR2
#endif

--------------------------------------------------------------------------------
https://graphviz.gitlab.io/_pages/doc/info/

dot -Tpng ngx_pool_t.dot -o ngx_pool_t.png
dot -Tpng ngx_chain_t.dot -o ngx_chain_t.png

--------------------------------------------------------------------------------

https://github.com/y123456yz/reading-code-of-nginx-1.9.2.git

--------------------------------------------------------------------------------

http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf
https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md
https://github.com/julycoding/The-Art-Of-Programming-By-July
http://vdisk.weibo.com/s/zrFL6OXJNfNVU

--------------------------------------------------------------------------------

https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91

叶子节点都是黑的，根节点都是黑的，红色有两个黑色的子节点


空树没有父节点
 void insert_case1(node *n){
     if(n->parent == NULL)
         n->color = BLACK;
     else
         insert_case2 (n);
 }

父节点为黑结束
 void insert_case2(node *n){
     if(n->parent->color == BLACK) // 黑的下面可以连两个红的
         return; /* 树仍旧有效*/
     else
         insert_case3 (n);
 }

父节点为红
 void insert_case3(node *n){
     if(uncle(n) != NULL && uncle (n)->color == RED) { // 有个红叔叔，父亲和叔叔都是红的
         n->parent->color = BLACK; // 父亲转黑
         uncle (n)->color = BLACK; // 叔叔转黑
         grandparent (n)->color = RED; // 祖父转红
         insert_case1(grandparent(n)); // 然后递归插入祖父
     }
     else
         insert_case4 (n);
 }

 void insert_case4(node *n){
     if(n == n->parent->right && n->parent == grandparent(n)->left) { // 自己是右子，父亲是左子
         rotate_left(n->parent);
         n = n->left;
     } else if(n == n->parent->left && n->parent == grandparent(n)->right) { // 自己是左子，父亲是右子
         rotate_right(n->parent);
         n = n->right;
     }
     insert_case5 (n); // 自己是左，父亲也是左，或者，自己是右，父亲也是右
 }


 void insert_case5(node *n){
     n->parent->color = BLACK;
     grandparent (n)->color = RED;
     if(n == n->parent->left && n->parent == grandparent(n)->left) { 自己是左，父亲也是左， 右转祖父
         rotate_right(grandparent(n));
     } else { // 自己是右，父亲也是右 左转祖父
         /* Here, n == n->parent->right && n->parent == grandparent (n)->right */
         rotate_left(grandparent(n));
     }
 }




















